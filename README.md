Реализация эффективного алгоритма поиска по строке в очень большом текстовом файле. 

Рассмотрим любую непустую подстроку t строки s. Тогда назовём множеством окончаний endpos(t) множество всех позиций в строке s,
в которых оканчиваются вхождения строки t. Мы будем называть две подстроки t_1 и t_2 endpos-эквивалентными, если их множества
окончаний совпадают: endpos(t_1) = endpos(t_2).

	"""
	Класс состояния ячейки автомата.
	Xранит всю информацию о конкретном переходе.

    ...

    Attributes
    ----------
    long_len : int
        длина наибольшей строки соответствующей State.
    link : int
        Суффиксная ссылка link ведёт в такое состояние, которому соответствует наидлиннейший суффикс строки,
        находящийся в другом классе endpos-эквивалентности.
    next : dict
        Список переходов из этого состояния.
    first_pos_of_end : int
        

    Methods
    -------
    __init__(self):
        Инициализация нулевого состояния.
    """

Дан текст T, и поступают запросы в виде: дана строка P, требуется узнать позицию начала первого вхождения строки P.

Асимптотика: Препроцессинг O(length(T)) и O(length (P)) на один запрос.

Реализация: Построение суффиксного автомата по тексту T.
Алгоритм онлайновый, т.е. будет добавляем по одному символу строки s, перестраивая соответствующим образом текущий автомат.

Файл загружается один раз, чтение файла происходит построчно, поэтому переполнение буффера не произойдёт. Затем происходит большое количество запросов на поиск.
